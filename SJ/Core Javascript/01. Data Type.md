# 01. 데이터 타입

자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고 이를 적절히 활용할 수 있게 되는 것이 목표!!

- 기본형
    - number, string, bollean, null, undefined, Symbol...
    - 값이 담긴 주솟값을 바로 복제
    - 불변값
        - 불변값과 상수를 명확히 구분할 필요가 있음
        - 불변성 여부 : 변경가능성의 대상 → 데이터 영역 메모리
        - 변수 상수 구분 여부 : 변경 가능성 대상 → 변수 영역 메모리
        - 예)
            
            ```jsx
            var a = 'abc';
            a = a + 'def';
            ```
            
            - 변수 a에 문자열 ‘abc’를 할당했다가 뒤에 ‘def’를 추가하면 ‘abc’가 ‘abcdef’로 바뀌는 것이 아니라 새로운 문자열 ‘abcdef’를 만든 다음 그 주소를 변수 a에 저장함. ‘abc’와 ‘abcdef’는 완전히 별개의 데이터.
            
             
            
            ```jsx
            var b = 5;
            var c = 5;
            ```
            
            - 같은 값을 다른 변수에 할당한다면 컴퓨터는 데이터 영역에서 같은 값을 찾고 있으면 그 주소 재활용
- 참조형
    - Object, Array, Function, Date, RegExp, Map, Set...
    - 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제
    - 기본형 데이터와의 차이는 ‘객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점. 객채가 별도로 할애한 영역은 변수영역일 뿐 ‘데이터 영역'은 기존 메모리 공간을 그대로 활용한다.
    - 데이터 영역에 저장된 값은 모두 불변값이지만 객체 별도 변수에는 다른값을 얼마든지 대입할 수 있기 때문에 흔히 참조형 데이터는 불변하지 않다(가변값이다)라고 한다.
    - ex)
        
        ```jsx
        var obj1 = {
        	a: 1,
        	b: 'bbb'
        };
        obj1.a = 2;
        ```
        
        - 변수 obj1이 바라보고 있는 주소는 변하지 않는다(’새로운 객체'가 만들어진 것이 아니라 기존 객체 내부 값만 바뀐 것)
    - 참조 카운트 : 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수
        - 참조 카운트가 0인 메모리 주소는 GC의 수거 대상
        - GC는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화상태에 임박할 때마다 자동으로 수거 대상들을 수거함.
        

C/C++, Java 등 정적 타입 언어는 메모리 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 나누어 정해놓았지만(메모리 용량이 매우 부족했던 시절에는 불가피한 선택), 자바스크립트는 메모리 용량이 과거보다 월등히 커진 상황에서 등장하였기 때문에 상대적으로 압박에서 자유로워 개발자가 형변환을 걱정해야 하는 상황이 훨씬 덜 발생.

기본형과 참조형 데이터 차이점

```jsx
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd'};
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

- a !== b
- obj1 === obj2
- 엄밀히 말하면 기본형은 주솟값 복사하는 과정이 한 번만 이루어지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있음

### undefined와 null

- undefined
    - 사용자가 명시적으로 지정하는 경우와 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우가 있다.
    - 자바스크립트 엔진이 부여하는 경우
        1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
            
            ```jsx
            var a;
            console.log(a);
            // ES6에서 등장한 let, const에 대해서는 undefined를 할당하지 않은 채로 초기화를 마치며, 
            // 이후 특정 값을 할당하기 전까지는 해당 변수에 접근할 수 없다.
            ```
            
        2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
            
            ```jsx
            var obj = { a: 1 };
            console.log(obj.b);
            
            ```
            
        3. return 문이 없거나 호출되지 않는 함수의 실행 결과
            
            ```jsx
            var func = function() {};
            var c = func();
            console.log(c);
            ```
            
    
    - undefined와 배열
        - 배열에 아무 값도 할당하지 않고 크기를 주었을 떄, 빈요소를 확보하지만 어떤 값 즉 undefined조차도 할당돼 있지 않는다.
        - undefined를 명시적으로 부여했을 경우 출력하면 undefined가 출력된다.
        - ‘undefined가 할당된 요소'와 달리 ‘비어있는 요소'는 배열 메서드들의 순회 대상에서 제외된다.
    
    - 사용자가 명시적으로 부여한 경우
        - undefined는 그 자체로 값이다. undefined가 비록 ‘비어있음'을 의미하긴 하지만, 하나의 값으로 동작하기 때문에 이 때의 프로퍼티나 배열의 요소는 고유의 키값이 실존하게 되고, 따라서 순회의 대상이 될 수 있다.

직접 undefined를 할당하지 말자!
undefined는 자바스크립트 엔진이 반환하는 경우에만 해당되게 하자!
같은 의미를 가진 null을 사용하자!

- null
    - typeof null은 object이다.
    - 이는 자바스크립트 자체 버그이다..
    
    ```jsx
    var n = null;
    console.log(typeof n); //object
    
    console.log(n == undefined); //true
    console.log(n == null); //true
    
    console.log(n === undefined); //false
    console.log(n === null); //true
    ```
    
    어떤 변수가 실제로 null인지 undefined인지는 동등연산자로 비교해서는 알 수 없고, 일치 연산자를 써야만 정확히 판별 가능하다.